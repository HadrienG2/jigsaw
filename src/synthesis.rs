//! Utilities for audio synthesis

use crate::{audio, AudioFrequency, AudioPhase, AudioSample, SamplingRateHz};
use more_asserts::*;

/// Type suitable for storing oscillator harmonics
//
// This guarantees that we can store harmonics as long as requested saw
// frequencies are above 1 Hz, which includes the whole audio range...
pub(crate) type HarmonicsCounter = SamplingRateHz;

/// Number of bits of the HarmonicsCounter integer type
const HARMONICS_COUNTER_BITS: u32 = (std::mem::size_of::<HarmonicsCounter>() as u32) * 8;

/// For oscillators whose analog counterpart have infinite frequency content,
/// such as sawtooth or square waves, tell how many harmonics must be generated
/// in order to get a maximally accurate band-limited signal.
pub(crate) fn band_limited_harmonics(
    sampling_rate: SamplingRateHz,
    oscillator_freq: AudioFrequency,
) -> HarmonicsCounter {
    // Check that the inputs make sense
    audio::validate_sampling_rate(sampling_rate);
    audio::validate_audio_frequency((sampling_rate, oscillator_freq));

    // Compute the number of harmonics of a band-limited signal
    let nyquist_frequency = audio::nyquist_frequency(sampling_rate);
    let num_harmonics = (nyquist_frequency / oscillator_freq).trunc();
    assert_le!(
        num_harmonics,
        HarmonicsCounter::MAX as AudioFrequency,
        "Oscillator frequency is too low, harmonics count overflows counter"
    );
    num_harmonics as _
}

/// Test that an harmonics count, such as the one generated by
/// band_limited_harmonics(), can be losslessly converted to a floating-point
/// type with a mantissa of N bits.
pub(crate) fn check_harmonics_precision(num_harmonics: HarmonicsCounter, mantissa_bits: u32) {
    if mantissa_bits < HARMONICS_COUNTER_BITS {
        assert_le!(
            num_harmonics,
            (2 as HarmonicsCounter).pow(mantissa_bits),
            "Too many harmonics to accurately represent them as floating-point",
        );
    }
}

/// This crate is all about implementing digital oscillators for audio synthesis
pub trait Oscillator: Iterator<Item = AudioSample> {
    /// Set up an oscillator
    fn new(
        sampling_rate: SamplingRateHz,
        oscillator_freq: AudioFrequency,
        initial_phase: AudioPhase,
    ) -> Self;
}

#[cfg(test)]
pub(crate) mod test_tools {
    use super::*;
    use crate::phase::OscillatorPhase;
    use quickcheck::{quickcheck, Arbitrary, Gen, TestResult, Testable};
    use std::cmp::Ordering;

    // Given a band-limited Oscillator implementation and the band-unlimited
    // signal that it tries to reproduce, check that the output is reasonable
    pub(crate) fn test_oscillator<O: Oscillator>(unlimited_signal: fn(AudioPhase) -> AudioSample) {
        test_low_freq_limit::<O>(unlimited_signal);
        test_high_freq_limit::<O>();
        test_any_freq::<O>();
    }

    /// Test that the band-limited oscillator is close to the unlimited signal
    /// when the oscillator frequency is much lower than the Nyquist limit.
    fn test_low_freq_limit<O: Oscillator>(unlimited_signal: fn(AudioPhase) -> AudioSample) {
        // This gets us as cose as possible to the non-band-limited case.
        let oscillator_freq = 20;
        let sampling_rate =
            2 * oscillator_freq * (2 as SamplingRateHz).pow(f32::MANTISSA_DIGITS + 1);
        let oscillator_freq = oscillator_freq as AudioFrequency;

        // HACK: quickcheck doesn't support closures due to quickcheck#56, which
        //       is itself blocked by rust#25041, so we need to massage our test
        //       closure a bit before quickcheck will accept it...
        //
        struct QuickCheckTest<Closure: Fn(AudioPhase) -> TestResult + Send + 'static>(Closure);
        //
        impl<Closure> Testable for QuickCheckTest<Closure>
        where
            Closure: Fn(AudioPhase) -> TestResult + Send + 'static,
        {
            fn result<G: Gen>(&self, gen: &mut G) -> TestResult {
                let phase = AudioPhase::arbitrary(gen);
                (self.0)(phase)
            }
        }
        //
        quickcheck(QuickCheckTest(move |initial_phase| {
            use crate::phase::AudioPhaseMod::consts::{PI, TAU};

            // Up to 0.9*pi, error is <= 1.5 AudioSample::EPSILON.
            // This is like a -134 dB audio noise => Should be imperceptible.
            // At 0.99*pi, error is <= 16 AudioSample::EPSILON.
            // This is like a -120 dB audio noise: still inaudible, but you
            // might hear a tiny bit of it if you summed lots and lots of them.
            // At 0.999*pi, error is <= 256 AudioSample::EPSILON.
            // This is like the noise of a 16-bit CD recording: audible, but
            // only if you have very good gear and turn up the volume like crazy.
            // At 0.9999*pi, error is <= 2048 AudioSample::EPSILON.
            // ...

            // TODO: Use binary search to figure out where in the phase space
            //       the error starts going above 1, 2, 4, 8, 16, 32... EPSILON.
            //       Tabulate this, plot the function, see if it's reasonably
            //       close to a nice analytical shape.
            //       If so, fit that shape and make it a parameter of this test,
            //       instead of using a constant AMPLITUDE_ERROR_THRESHOLD which
            //       is quite obviously wrong...
            //       ...then remove the hacks below
            let proximity_to_pi = 0.9999;
            let spread = 0.1 * (1.0 - proximity_to_pi);
            let initial_phase = proximity_to_pi * PI + spread * (initial_phase % TAU);

            let oscillator = O::new(sampling_rate, oscillator_freq, initial_phase);
            let phase = OscillatorPhase::new(sampling_rate, oscillator_freq, initial_phase);
            const SAMPLES_PER_TEST: usize = 5;
            const AMPLITUDE_ERROR_THRESHOLD: AudioSample = 65536.0;
            let samples = oscillator
                .zip(phase.map(unlimited_signal))
                .map(|(limited, unlimited)| {
                    (
                        limited,
                        unlimited,
                        (limited - unlimited).abs() / AudioSample::EPSILON,
                    )
                })
                .take(SAMPLES_PER_TEST)
                .collect::<Vec<_>>();
            println!(
                "Done performing accuracy test for an initial phase of {} (= {}pi [2pi])",
                initial_phase,
                (initial_phase + PI).rem_euclid(TAU) / PI - 1.0
            );
            let max_error = samples
                .iter()
                .map(|&(_s1, _s2, e)| e)
                .max_by(|e1, e2| {
                    if e1 < e2 {
                        Ordering::Less
                    } else {
                        Ordering::Greater
                    }
                })
                .unwrap();
            if max_error > AMPLITUDE_ERROR_THRESHOLD {
                println!("Amplitude accuracy was below quality threshold");
                println!("limited,unlimited,error");
                for (limited, unlimited, reldif) in samples {
                    println!("{},{},{}", limited, unlimited, reldif);
                }
                println!("------");
                TestResult::failed()
            } else {
                println!(
                    "Amplitude accuracy was above quality threshold ({} <= {} eps)",
                    max_error, AMPLITUDE_ERROR_THRESHOLD
                );
                TestResult::passed()
            }
        }))
    }

    /// Test that the band-limited oscillator is a perfect sine when the
    /// oscillator frequency is above half or the Nyquist limit.
    fn test_high_freq_limit<O: Oscillator>() {
        todo!()
    }

    /// Test general properties of the band-limited oscillator in the
    /// intermediate regime between these two extreme scenarios: periodicity,
    /// amplitude...
    fn test_any_freq<O: Oscillator>() {
        todo!()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{
        audio::{test_tools as audio_tests, NonZeroSamplingRate},
        test_tools::panics,
    };
    use audio_tests::is_standard_rate;
    use quickcheck::{quickcheck, TestResult};

    mod band_limited_harmonics {
        use super::*;

        /// Minimal input frequency for this function
        fn min_freq(rate: SamplingRateHz) -> AudioFrequency {
            let max_harmonics = HarmonicsCounter::MAX as AudioFrequency;
            audio::nyquist_frequency(rate) / max_harmonics
        }

        /// Test that a requested oscillator frequency falls into the ideal range.
        /// Other frequencies are tested via specific edge-case tests.
        fn is_standard_freq(rate: NonZeroSamplingRate, freq: AudioFrequency) -> bool {
            audio_tests::is_standard_freq(rate, freq) && freq <= min_freq(rate.get())
        }

        quickcheck! {
            /// Test reasonable sampling rates and frequencies
            fn general_case(rate: NonZeroSamplingRate, freq: AudioFrequency) -> TestResult {
                // Avoid edge cases which are left to dedicated tests
                if !(is_standard_rate(rate) && is_standard_freq(rate, freq)) {
                    return TestResult::discard();
                }

                // Check the amount of band-limited harmonics
                // TODO: Handle "too many harmonics scenario as a separate test
                let rate = rate.get();
                let num_harmonics = band_limited_harmonics(rate, freq);
                let num_harmonics = num_harmonics as AudioFrequency;
                let nyquist_frequency = audio::nyquist_frequency(rate);
                assert_le!(num_harmonics * freq, nyquist_frequency);
                assert_gt!((num_harmonics + 1.0) * freq, nyquist_frequency);
                TestResult::passed()
            }

            /// Test excessively low frequencies
            fn too_many_harmonics(rate: NonZeroSamplingRate) -> bool {
                let rate = rate.get();
                panics(|| band_limited_harmonics(rate, 0.99 * min_freq(rate)))
                    && panics(|| band_limited_harmonics(rate, 0.01 * min_freq(rate)))
            }
        }
    }

    quickcheck! {
        fn check_harmonics_precision(num_harmonics: HarmonicsCounter) -> bool {
            use super::check_harmonics_precision;
            assert_eq!(
                panics(|| check_harmonics_precision(num_harmonics, f32::MANTISSA_DIGITS)),
                (num_harmonics as f32) as HarmonicsCounter != num_harmonics,
            );
            assert_eq!(
                panics(|| check_harmonics_precision(num_harmonics, f64::MANTISSA_DIGITS)),
                (num_harmonics as f64) as HarmonicsCounter != num_harmonics,
            );
            true
        }
    }
}
