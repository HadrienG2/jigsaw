//! Utilities for audio synthesis

use crate::{audio, AudioFrequency, AudioPhase, AudioSample, SamplingRateHz};
use f128::f128;
use more_asserts::*;
use num_traits::{cast, Float};

/// Type suitable for storing oscillator harmonics
//
// This guarantees that we can store harmonics as long as requested saw
// frequencies are above 1 Hz, which includes the whole audio range...
pub(crate) type HarmonicsCounter = SamplingRateHz;

/// Number of bits of the HarmonicsCounter integer type
const HARMONICS_COUNTER_BITS: u32 = (std::mem::size_of::<HarmonicsCounter>() as u32) * 8;

/// For oscillators whose analog counterpart have infinite frequency content,
/// such as sawtooth or square waves, tell how many harmonics must be generated
/// in order to get a maximally accurate band-limited signal.
pub(crate) fn band_limited_harmonics(
    sampling_rate: SamplingRateHz,
    oscillator_freq: AudioFrequency,
) -> HarmonicsCounter {
    // Check that the inputs make sense
    audio::validate_sampling_rate(sampling_rate);
    audio::validate_audio_frequency((sampling_rate, oscillator_freq));

    // Compute the number of harmonics of a band-limited signal
    let nyquist_frequency = audio::nyquist_frequency(sampling_rate);
    let num_harmonics = (nyquist_frequency / oscillator_freq).trunc();
    assert_le!(
        num_harmonics,
        HarmonicsCounter::MAX as AudioFrequency,
        "Oscillator frequency is too low, harmonics count overflows counter"
    );
    num_harmonics as _
}

/// Test that an harmonics count, such as the one generated by
/// band_limited_harmonics(), can be losslessly converted to a floating-point
/// type with a mantissa of N bits.
pub(crate) fn check_harmonics_precision(num_harmonics: HarmonicsCounter, mantissa_bits: u32) {
    if mantissa_bits < HARMONICS_COUNTER_BITS {
        assert_le!(
            num_harmonics,
            (2 as HarmonicsCounter).pow(mantissa_bits),
            "Too many harmonics to accurately represent them as floating-point",
        );
    }
}

/// Given a fundamental sinus' phase, compute the value of all of its sinus
/// harmonics up to a certain rank with quadruple precision
///
/// The result is guaranteed to be accurate within one f64 ulp. But the price to
/// pay for this extreme precision is horrible CPU performance due to the use of
/// libquadmath's software quadruple precision.
///
/// Therefore, this implementation is only meant to be used for mathematical
/// validation of other harmonics generation methods.
///
pub(crate) fn sin_harmonics_1ulp(
    phase: f64,
    num_harmonics: HarmonicsCounter,
) -> impl Iterator<Item = f64> {
    (1..=num_harmonics).map(move |harmonic| {
        // Lossless from an f64 point of view (f128 has twice the mantissa bits)
        let harmonic_phase_f128 = f128::from(harmonic) * f128::from(phase);
        // Within one f128 ulp of true result, which is << one f64 ulp
        harmonic_phase_f128.sin().into()
    })
}

/// Given a fundamental sinus' phase, compute the value of all of its sinus
/// harmonics up to a certain rank with (configurable) standard precision.
///
/// The result's error does not grow with the input phase, but grows linearly as
/// the harmonic rank increases. Which is not a problem for this library, as the
/// output sines and cosines will be divided by their harmonic rank in the final
/// Fourier series summation, which will get us back to constant error.
///
/// You can pick the precision in which the harmonics will be computed, but f64
/// will be slow, and f32 won't be much faster and will be too imprecise.
///
/// This is where the other harmonics computation methods come in.
///
pub(crate) fn sin_harmonics_precise<F: Float>(
    phase: f64,
    num_harmonics: HarmonicsCounter,
) -> impl Iterator<Item = f64> {
    (1..=num_harmonics).map(move |harmonic| {
        // Perform phase range wrapping to bound the multiplicative rounding
        // error that will be caused by harmonic elevation.
        // Result is within ]-TAU; TAU[, so assuming the input phase was
        // perfectly accurate, the new rounding error is <= f64::EPSILON * TAU.
        use core::f64::consts::TAU;
        let wrapped_phase = phase % TAU;

        // Perform harmonic elevation before casting to final float type.
        // Output rounding error is <= f64::EPSILON * harmonic * wrapped_phase
        // which per the above is <= f64::EPSILON * harmonic * TAU.
        let harmonic_phase = harmonic as f64 * wrapped_phase;

        // Cast to the sinus computation precision. Result error will be bounded
        // by max(F::epsilon() * harmonic_phase, f64::EPSILON * harmonic * TAU)
        let harmonic_phase = cast::<f64, F>(harmonic_phase).unwrap();

        // ...therefore, the error of the final sinus is either one F ulp or
        // or f64::EPSILON * harmonic * TAU, whichever is greater
        cast(harmonic_phase.sin()).unwrap()
    })
}

/// Given a fundamental sin/cos pair, compute the value of all of its (sin, cos)
/// harmonics using an iterative approach based on the
/// sincos((n+1)x) = f(sincos(nx)) trigonometric identities.
///
/// This approach doesn't use more memory than the naive approach, but is not
/// super precise and will break down relatively quickly as num_harmonics goes
/// up. It is only viable because we have to compute at twice the precision of
/// the desired result for accumulation error reasons.
///
/// Also, it doesn't vectorize as well as the following approach.
///
pub(crate) fn sincos_harmonics_iterative(
    (sin_1, cos_1): (f64, f64),
    num_harmonics: HarmonicsCounter,
) -> impl Iterator<Item = (f64, f64)> {
    let (mut sin_n, mut cos_n) = (0.0, 1.0);
    std::iter::from_fn(move || {
        let (sin, cos) = (sin_n * cos_1 + cos_n * sin_1, cos_n * cos_1 - sin_n * sin_1);
        sin_n = sin;
        cos_n = cos;
        Some((sin, cos))
    })
    .take(num_harmonics as usize)
}

/// Like sincos_harmonics_iterative, but uses higher-precision arithmetic
/// internally in order to achieve better output precision.
pub(crate) fn sincos_harmonics_iterative_f128(
    (sin_1, cos_1): (f128, f128),
    num_harmonics: HarmonicsCounter,
) -> impl Iterator<Item = (f64, f64)> {
    let (mut sin_n, mut cos_n) = (f128::from(0.0), f128::from(1.0));
    std::iter::from_fn(move || {
        let (sin, cos) = (sin_n * cos_1 + cos_n * sin_1, cos_n * cos_1 - sin_n * sin_1);
        sin_n = sin;
        cos_n = cos;
        Some((sin.into(), cos.into()))
    })
    .take(num_harmonics as usize)
}

/// Given a fundamental sin/cos pair, compute the value of all of its (sin, cos)
/// harmonics using a recursive approach inspired by the FFT algorithm.
///
/// This approach requires a storage buffer for num_harmonics (sin, cos) pairs,
/// but it is more precise than the previous one (each harmonic is a sum of only
/// O(log2(prev_harmonics)) terms, not O(prev_harmonics) terms) and vectorizes
/// very well so as long as the buffer fits in the L1 cache it will be faster.
///
pub(crate) fn sincos_harmonics_smart(
    (sin_1, cos_1): (f64, f64),
    (sin_buf, cos_buf): (&mut [f64], &mut [f64]),
) {
    let num_harmonics = sin_buf.len();
    let sin_buf = &mut sin_buf[..num_harmonics];
    let cos_buf = &mut cos_buf[..num_harmonics];
    sin_buf[0] = sin_1;
    cos_buf[0] = cos_1;
    let mut computed_harmonics = 1;
    while computed_harmonics < num_harmonics {
        let ref_cos = cos_buf[computed_harmonics - 1];
        let ref_sin = sin_buf[computed_harmonics - 1];
        let remaining_harmonics = num_harmonics - computed_harmonics;
        let incoming_harmonics = computed_harmonics.min(remaining_harmonics);
        for old_harmonic in 0..incoming_harmonics {
            let new_harmonic = old_harmonic + computed_harmonics;
            // Safety: This is safe because by construction, neither
            //         old_harmonic not new_harmonic can go above
            //         num_harmonics. It is necessary because right now,
            //         rustc's bound check elision is not smart enough and
            //         kills autovectorization, which is unacceptable.
            unsafe {
                *sin_buf.get_unchecked_mut(new_harmonic) = sin_buf.get_unchecked(old_harmonic)
                    * ref_cos
                    + cos_buf.get_unchecked(old_harmonic) * ref_sin;
                *cos_buf.get_unchecked_mut(new_harmonic) = cos_buf.get_unchecked(old_harmonic)
                    * ref_cos
                    - sin_buf.get_unchecked(old_harmonic) * ref_sin;
            }
        }
        computed_harmonics *= 2;
    }
}

/// This crate is all about implementing digital oscillators for audio synthesis
///
/// All digital oscillators produce a band-limited approximation of a
/// band-unlimited mathematical function ranging from -1.0 to 1.0.
//
// TODO: Add support for applying windowing to non-audible harmonics so that the
//       Gibbs phenomenon is less annoying. The goal is to spread its energy so
//       that worst-case error goes down.
pub trait Oscillator: Iterator<Item = AudioSample> {
    /// Set up an oscillator
    fn new(
        sampling_rate: SamplingRateHz,
        oscillator_freq: AudioFrequency,
        initial_phase: AudioPhase,
    ) -> Self;

    // TODO: Add a method to query the amount of Gibbs phenomenon overshoot,
    //       that users can leverage to tune down the amplitude when a signal is
    //       to be sent to the loudspeakers and clipping must be avoided.
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{
        audio::{test_tools as audio_tests, NonZeroSamplingRate},
        test_tools::panics,
    };
    use audio_tests::is_standard_rate;
    use quickcheck::{quickcheck, TestResult};

    mod band_limited_harmonics {
        use super::*;

        /// Minimal input frequency for this function
        fn min_freq(rate: SamplingRateHz) -> AudioFrequency {
            let max_harmonics = HarmonicsCounter::MAX as AudioFrequency;
            audio::nyquist_frequency(rate) / max_harmonics
        }

        /// Test that a requested oscillator frequency falls into the ideal range.
        /// Other frequencies are tested via specific edge-case tests.
        fn is_standard_freq(rate: NonZeroSamplingRate, freq: AudioFrequency) -> bool {
            audio_tests::is_standard_freq(rate, freq) && freq <= min_freq(rate.get())
        }

        quickcheck! {
            /// Test reasonable sampling rates and frequencies
            fn general_case(rate: NonZeroSamplingRate, freq: AudioFrequency) -> TestResult {
                // Avoid edge cases which are left to dedicated tests
                if !(is_standard_rate(rate) && is_standard_freq(rate, freq)) {
                    return TestResult::discard();
                }

                // Check the amount of band-limited harmonics
                // TODO: Handle "too many harmonics scenario as a separate test
                let rate = rate.get();
                let num_harmonics = band_limited_harmonics(rate, freq);
                let num_harmonics = num_harmonics as AudioFrequency;
                let nyquist_frequency = audio::nyquist_frequency(rate);
                assert_le!(num_harmonics * freq, nyquist_frequency);
                assert_gt!((num_harmonics + 1.0) * freq, nyquist_frequency);
                TestResult::passed()
            }

            /// Test excessively low frequencies
            fn too_many_harmonics(rate: NonZeroSamplingRate) -> bool {
                let rate = rate.get();
                panics(|| band_limited_harmonics(rate, 0.99 * min_freq(rate)))
                    && panics(|| band_limited_harmonics(rate, 0.01 * min_freq(rate)))
            }
        }
    }

    quickcheck! {
        fn check_harmonics_precision(num_harmonics: HarmonicsCounter) -> bool {
            use super::check_harmonics_precision;
            assert_eq!(
                panics(|| check_harmonics_precision(num_harmonics, f32::MANTISSA_DIGITS)),
                (num_harmonics as f32) as HarmonicsCounter != num_harmonics,
            );
            assert_eq!(
                panics(|| check_harmonics_precision(num_harmonics, f64::MANTISSA_DIGITS)),
                (num_harmonics as f64) as HarmonicsCounter != num_harmonics,
            );
            true
        }
    }

    // ---

    /// Expected n-th harmonic of a certain sincos (f128 version)
    fn expected_sincos_harmonic_f128(phase: f64, harmonic: HarmonicsCounter) -> (f64, f64) {
        let (expected_sin_f128, expected_cos_f128) =
            (f128::from(phase) * f128::from(harmonic)).sin_cos();
        (expected_sin_f128.into(), expected_cos_f128.into())
    }

    /// Expected n-th harmonic of a certain sincos (arbitrary-precision version)
    fn expected_sincos_harmonic_rug(
        phase: f64,
        harmonic: HarmonicsCounter,
        precision: u32,
    ) -> (f64, f64) {
        let (expected_sin_rug, expected_cos_rug) = (rug::Float::with_val(precision, phase)
            * rug::Float::with_val(precision, harmonic))
        .sin_cos(rug::Float::new(precision));
        (expected_sin_rug.to_f64(), expected_cos_rug.to_f64())
    }

    quickcheck! {
        /// Proof that f128 is enough to get a perfect f64 harmonic sincos
        fn rug_f128_agreement(phase: f64, harmonic: HarmonicsCounter) -> TestResult {
            // Disregard IEEE-754 abominations in this test
            if !phase.is_normal() {
                return TestResult::discard();
            }

            // The libquadmath harmonic sincos seems to be accurate within 1 f64
            // ulp, in the sense that when it's rounded down to f64 precision,
            // there is no difference with a hugely precise MPFR/rug sincos.
            const OBSCENE_PRECISON: u32 = 1024;
            let (computed_sin, computed_cos) = expected_sincos_harmonic_f128(phase, harmonic);
            let (expected_sin, expected_cos) = expected_sincos_harmonic_rug(phase, harmonic, OBSCENE_PRECISON);
            assert_eq!(computed_sin, expected_sin);
            assert_eq!(computed_cos, expected_cos);
            TestResult::passed()
        }

        /// Test of f64 harmonic sincos precision
        fn f64_f128_agreement(phase: f64, harmonic: HarmonicsCounter) -> TestResult {
            // Disregard IEEE-754 abominations and the zeroth harmonic in this test
            if !phase.is_normal() || harmonic == 0 {
                return TestResult::discard();
            }

            // The f64 sincos is within 1 f64 ulp of the f128 sincos...
            let (computed_sin1, computed_cos1) = phase.sin_cos();
            let (expected_sin1, expected_cos1) = expected_sincos_harmonic_f128(phase, 1);
            assert_le!((computed_sin1 - expected_sin1).abs(), f64::EPSILON * expected_sin1.abs());
            assert_le!((computed_cos1 - expected_cos1).abs(), f64::EPSILON * expected_cos1.abs());

            // ..and the HarmonicsCounter -> f64 conversion is lossless...
            let harmonic_f64 = harmonic as f64;
            assert_eq!(harmonic_f64 as HarmonicsCounter, harmonic);
            assert_eq!(harmonic_f64.fract(), 0.0);

            // ...but the phase-harmonic multiplication amplifies phase error...
            let harmonic_phase_f64 = harmonic_f64 * phase;
            let harmonic_phase_f128 = f128::from(harmonic) * f128::from(phase);
            let residual: f64 = (f128::from(harmonic_phase_f64) - harmonic_phase_f128).into();
            assert_le!(residual.abs(), f64::EPSILON * harmonic_phase_f64.abs());

            // ...which, in turn, leads to a sincos error that is a function of
            // both the input phase and the input harmonic number.
            let (computed_sin, computed_cos) = harmonic_phase_f64.sin_cos();
            let (expected_sin, expected_cos) = expected_sincos_harmonic_f128(phase, harmonic);
            assert_le!((computed_sin - expected_sin).abs(), f64::EPSILON * harmonic_f64 * phase.abs());
            assert_le!((computed_cos - expected_cos).abs(), f64::EPSILON * harmonic_f64 * phase.abs());

            // We can bound this effect so that the error is only proportional
            // to the harmonic number (which is good enough for our purposes,
            // as we're going to divide by the harmonic number in the end) by
            // doing range-wrapping before harmonic elevation.
            use core::f64::consts::TAU;
            let wrapped_harmonic_phase_f64 = harmonic_f64 * (phase % TAU);
            let (wrapped_sin, wrapped_cos) = wrapped_harmonic_phase_f64.sin_cos();
            assert_le!((wrapped_sin - expected_sin).abs(), 18.0 * f64::EPSILON * harmonic_f64);
            assert_le!((wrapped_cos - expected_cos).abs(), 18.0 * f64::EPSILON * harmonic_f64);
            TestResult::passed()
        }
    }

    // ---

    /// Test harness for sinus harmonics generators
    fn test_sin_harmonics<G, I>(
        phase: f64,
        num_harmonics: HarmonicsCounter,
        generator: G,
        expected_precision: impl Fn(f64, HarmonicsCounter, f64) -> f64,
    ) -> TestResult
    where
        I: Iterator<Item = f64>,
        G: FnOnce(f64, HarmonicsCounter) -> I,
    {
        // Disregard IEEE-754 abominations in this test
        if !phase.is_normal() {
            return TestResult::discard();
        }

        // Check the result against expectation
        let mut observed_harmonics = 0;
        for sin_harmonic in generator(phase, num_harmonics) {
            observed_harmonics += 1;
            let (expected_sin, _expected_cos) =
                expected_sincos_harmonic_f128(phase, observed_harmonics);
            assert_le!(
                (sin_harmonic - expected_sin).abs(),
                expected_precision(phase, observed_harmonics, expected_sin.abs())
            );
        }
        assert_eq!(observed_harmonics, num_harmonics);
        TestResult::passed()
    }

    quickcheck! {
        /// Test the "1-ulp" generation algorithm
        fn sin_harmonics_1ulp(
            phase: f64,
            num_harmonics: HarmonicsCounter
        ) -> TestResult {
            test_sin_harmonics(
                phase,
                num_harmonics,
                super::sin_harmonics_1ulp,
                |_phase, _harmonic, expected_sin| 0.5 * f64::EPSILON * expected_sin
            )
        }

        /// Test the f32 version of the "precise" algorithm
        fn sin_harmonics_precise_f32(
            phase: f64,
            num_harmonics: HarmonicsCounter
        ) -> TestResult {
            test_sin_harmonics(
                phase,
                num_harmonics,
                super::sin_harmonics_precise::<f32>,
                |_phase, harmonic, _expected_sin| 4.0 * f32::EPSILON as f64 * harmonic as f64
            )
        }

        /// Test the f64 version of the "precise" algorithm
        fn sin_harmonics_precise_f64(
            phase: f64,
            num_harmonics: HarmonicsCounter
        ) -> TestResult {
            test_sin_harmonics(
                phase,
                num_harmonics,
                super::sin_harmonics_precise::<f64>,
                |_phase, harmonic, _expected_sin| 19.0 * f64::EPSILON * harmonic as f64
            )
        }
    }

    // ---

    // TODO: Write a sincos test harness as above, then use it to test sincos generators
}
