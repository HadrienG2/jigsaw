pub(crate) mod audio;
mod phase;

pub use crate::{
    audio::{AudioFrequency, AudioSample, SamplingRateHz},
    phase::min_oscillator_freq,
};
use phase::{AudioPhase, OscillatorPhase};

// === AUDIO SYNTHESIS UTILITIES ===

/// Type suitable for storing oscillator harmonics
//
// This guarantees that we can store harmonics as long as requested saw
// frequencies are above 1 Hz, which includes the whole audio range...
type HarmonicsCounter = SamplingRateHz;

/// For oscillators whose analog counterpart have infinite frequency content,
/// such as sawtooth or square waves, tell how many harmonics must be generated
/// in order to get a maximally accurate band-limited signal.
fn band_limited_harmonics(
    sampling_rate: SamplingRateHz,
    oscillator_freq: AudioFrequency,
) -> HarmonicsCounter {
    let nyquist_frequency = (sampling_rate as AudioFrequency) / 2.0;
    let num_harmonics = (nyquist_frequency / oscillator_freq).trunc();
    assert!(
        num_harmonics < (2.0 as AudioFrequency).powi(32),
        "Oscillator frequency is too low, harmonics count overflows counter"
    );
    num_harmonics as _
}

/// Test that an harmonics count, such as the one generated by
/// band_limited_harmonics(), can be losslessly converted to a floating-point
/// type with a mantissa of N bits.
fn check_harmonics_precision(num_harmonics: HarmonicsCounter, mantissa_bits: u32) {
    let harmonic_counter_bits = std::mem::size_of::<HarmonicsCounter>() * 8;
    if (mantissa_bits as usize) < harmonic_counter_bits {
        assert!(
            num_harmonics <= (2 as HarmonicsCounter).pow(mantissa_bits),
            "Too many harmonics to accurately represent them as floating-point",
        );
    }
}

/// Compute the n-th harmonic number, that is, sum(1..=n, 1/n)
fn harmonic_number(num_harmonics: HarmonicsCounter) -> AudioSample {
    // TODO: Find out after how many harmonics this sum becomes wrong by more
    //       than 2^-24 and assert that this limit is not reached.
    (1..=num_harmonics)
        .map(|harmonic| 1.0 / (harmonic as f64))
        .sum::<f64>() as AudioSample
}

/// This crate is all about implementing digital oscillators for audio synthesis
pub trait Oscillator: Iterator<Item = AudioSample> {
    /// Set up an oscillator
    fn new(
        sampling_rate: SamplingRateHz,
        oscillator_freq: AudioFrequency,
        initial_phase: AudioPhase,
    ) -> Self;
}

// === SAW GENERATORS ===

// This computes a band-limited sawtooth wave with maximal precision, at the
// cost of speed. It is intended as a speed and precision reference against
// which other speed-optimized sawtooth wave generators can be compared
pub struct ReferenceSaw {
    // Underlying oscillator phase iterator
    phase: OscillatorPhase,

    // Number of harmonics to be generated
    num_harmonics: HarmonicsCounter,

    // Amplitude norm, chosen so that the output is between -1.0 and +1.0
    amplitude_norm: f64,
}

impl Oscillator for ReferenceSaw {
    /// Set up a sawtooth oscillator.
    fn new(
        sampling_rate: SamplingRateHz,
        oscillator_freq: AudioFrequency,
        initial_phase: AudioPhase,
    ) -> Self {
        // Set up the oscillator's phase clock
        let phase = OscillatorPhase::new(sampling_rate, oscillator_freq, initial_phase);

        // Determine how many harmonics must be generated
        let num_harmonics = band_limited_harmonics(sampling_rate, oscillator_freq);
        check_harmonics_precision(num_harmonics, f64::MANTISSA_DIGITS);

        // Compute the amplitude norm, which is the harmonic number
        let amplitude_norm = harmonic_number(num_harmonics) as f64;

        // We're ready to generate signal
        Self {
            phase,
            num_harmonics,
            amplitude_norm,
        }
    }
}

impl Iterator for ReferenceSaw {
    type Item = AudioSample;

    fn next(&mut self) -> Option<Self::Item> {
        // This implementation is meant to be as accurate as possible, not fast.
        // So it uses double precision and avoids "performance over precision"
        // tricks such as turning division into multiplication by inverse.
        let phase = self.phase.next()? as f64;
        let mut accumulator = 0.0;
        for harmonic in 1..=self.num_harmonics {
            let harmonic = harmonic as f64;
            accumulator += (harmonic * phase).sin() / harmonic;
        }
        accumulator /= self.amplitude_norm;
        Some(accumulator as _)
    }
}

// TODO: Do a version that still uses libm sinus, but uses f32 precision,
//       multiplication by inverse, and caches all the 1/harmonic inverses in a
//       lookup table. Compare precision and performance.
//
//       This should be done after extracting as many common blocks as possible
//       from the reference implementation. We're almost there!

// TODO: Implement the sinus avoidance optimizations that this project has
//       always been meant to test, compare precision and performance.

// TODO: Add correctness tests
#[cfg(test)]
mod tests {
    // TODO: Test min_x_freq functions
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
