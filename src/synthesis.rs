//! Utilities for audio synthesis

use crate::{audio, AudioFrequency, AudioPhase, AudioSample, SamplingRateHz};
use more_asserts::*;

/// Type suitable for storing oscillator harmonics
//
// This guarantees that we can store harmonics as long as requested saw
// frequencies are above 1 Hz, which includes the whole audio range...
pub(crate) type HarmonicsCounter = SamplingRateHz;

/// Number of bits of the HarmonicsCounter integer type
const HARMONICS_COUNTER_BITS: u32 = (std::mem::size_of::<HarmonicsCounter>() as u32) * 8;

/// For oscillators whose analog counterpart have infinite frequency content,
/// such as sawtooth or square waves, tell how many harmonics must be generated
/// in order to get a maximally accurate band-limited signal.
pub(crate) fn band_limited_harmonics(
    sampling_rate: SamplingRateHz,
    oscillator_freq: AudioFrequency,
) -> HarmonicsCounter {
    // Check that the inputs make sense
    audio::validate_sampling_rate(sampling_rate);
    audio::validate_audio_frequency((sampling_rate, oscillator_freq));

    // Compute the number of harmonics of a band-limited signal
    let nyquist_frequency = audio::nyquist_frequency(sampling_rate);
    let num_harmonics = (nyquist_frequency / oscillator_freq).trunc();
    assert_le!(
        num_harmonics,
        HarmonicsCounter::MAX as AudioFrequency,
        "Oscillator frequency is too low, harmonics count overflows counter"
    );
    num_harmonics as _
}

/// Test that an harmonics count, such as the one generated by
/// band_limited_harmonics(), can be losslessly converted to a floating-point
/// type with a mantissa of N bits.
pub(crate) fn check_harmonics_precision(num_harmonics: HarmonicsCounter, mantissa_bits: u32) {
    if mantissa_bits < HARMONICS_COUNTER_BITS {
        assert_le!(
            num_harmonics,
            (2 as HarmonicsCounter).pow(mantissa_bits),
            "Too many harmonics to accurately represent them as floating-point",
        );
    }
}

/// Compute the n-th harmonic number, that is, sum(1..=n, 1/n)
pub(crate) fn harmonic_number(num_harmonics: HarmonicsCounter) -> AudioSample {
    // Handle trivial cases
    if num_harmonics <= 1 {
        return num_harmonics as _;
    }

    // Compute harmonic number, splitting out the last term's computation...
    let prev_number = (1..num_harmonics)
        .map(|harmonic| 1.0 / (harmonic as f64))
        .sum::<f64>();
    let last_contrib = 1.0 / (num_harmonics as f64);
    let result = prev_number + last_contrib;

    // ...so that we can check final summation error as a coarse but hopefully
    // good enough indicator of how wrong the result is.
    let error = (result - prev_number) - last_contrib;
    assert_lt!(
        error.abs(),
        AudioSample::EPSILON as f64 / 2.0,
        "Too many harmonics to accurately compute the harmonic number"
    );
    result as AudioSample
}

/// This crate is all about implementing digital oscillators for audio synthesis
pub trait Oscillator: Iterator<Item = AudioSample> {
    /// Set up an oscillator
    fn new(
        sampling_rate: SamplingRateHz,
        oscillator_freq: AudioFrequency,
        initial_phase: AudioPhase,
    ) -> Self;
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{
        audio::{test_tools as audio_tests, NonZeroSamplingRate},
        test_tools::panics,
    };
    use audio_tests::is_standard_rate;
    use quickcheck::{quickcheck, TestResult};

    mod band_limited_harmonics {
        use super::*;

        /// Minimal input frequency for this function
        fn min_freq(rate: SamplingRateHz) -> AudioFrequency {
            let max_harmonics = HarmonicsCounter::MAX as AudioFrequency;
            audio::nyquist_frequency(rate) / max_harmonics
        }

        /// Test that a requested oscillator frequency falls into the ideal range.
        /// Other frequencies are tested via specific edge-case tests.
        fn is_standard_freq(rate: NonZeroSamplingRate, freq: AudioFrequency) -> bool {
            audio_tests::is_standard_freq(rate, freq) && freq <= min_freq(rate.get())
        }

        quickcheck! {
            /// Test reasonable sampling rates and frequencies
            fn general_case(rate: NonZeroSamplingRate, freq: AudioFrequency) -> TestResult {
                // Avoid edge cases which are left to dedicated tests
                if !(is_standard_rate(rate) && is_standard_freq(rate, freq)) {
                    return TestResult::discard();
                }

                // Check the amount of band-limited harmonics
                // TODO: Handle "too many harmonics scenario as a separate test
                let rate = rate.get();
                let num_harmonics = band_limited_harmonics(rate, freq);
                let num_harmonics = num_harmonics as AudioFrequency;
                let nyquist_frequency = audio::nyquist_frequency(rate);
                assert_le!(num_harmonics * freq, nyquist_frequency);
                assert_gt!((num_harmonics + 1.0) * freq, nyquist_frequency);
                TestResult::passed()
            }

            /// Test excessively low frequencies
            fn too_many_harmonics(rate: NonZeroSamplingRate) -> bool {
                let rate = rate.get();
                panics(|| band_limited_harmonics(rate, 0.99 * min_freq(rate)))
                    && panics(|| band_limited_harmonics(rate, 0.01 * min_freq(rate)))
            }
        }
    }

    quickcheck! {
        fn check_harmonics_precision(num_harmonics: HarmonicsCounter) -> bool {
            use super::check_harmonics_precision;
            assert_eq!(
                panics(|| check_harmonics_precision(num_harmonics, f32::MANTISSA_DIGITS)),
                (num_harmonics as f32) as HarmonicsCounter != num_harmonics,
            );
            assert_eq!(
                panics(|| check_harmonics_precision(num_harmonics, f64::MANTISSA_DIGITS)),
                (num_harmonics as f64) as HarmonicsCounter != num_harmonics,
            );
            true
        }

        fn harmonic_number(num_harmonics: HarmonicsCounter) -> TestResult {
            use super::harmonic_number;
            // We expect harmonic number computations to work for band*limited
            // signals from the beginning of the audio range, on the highest end
            // sound cards available at the time this crate is released.
            if num_harmonics >= 1 && num_harmonics < (192_000 / 2) / 20 {
                let actual = harmonic_number(num_harmonics);
                let expected = (harmonic_number(num_harmonics - 1) as f64 + 1.0 / (num_harmonics as f64)) as AudioSample;
                assert_lt!((actual - expected) / expected, AudioSample::EPSILON);
                TestResult::passed()
            } else {
                TestResult::discard()
            }
        }
    }

    // TODO: Add correctness tests, including a generic oscillator test that
    //       takes the band-unlimited version as input and compares against it
    //       for a very high sampling rate / frequency ratio (say,
    //       2^f32::MANTISSA_BITS), where the two versions should be ~identical.
}
